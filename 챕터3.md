<챕터 3>

인덱스 RowId 
- 데이터베이스 테이블의 각 행이 저장된 물리적 위치를 나타내는 고유 식별자
- 인덱스 구조 : 사용자가 지정한 컬럼(key), 해당 행의 RowId

클러스터형 인덱스
- 테이블의 실제 데이터 행 자체를 인덱스 키순서대로 정렬하여 저장
- 리프 페이지가 곧 실제 데이터 페이지
- 테이블 당 1개만존재, 주로 pk에 설정

비 클러스터형 인덱스
- 인덱스 구조와 실제 데이터 저장 방식이 분리되어 있음
- 리프 노드에는 인덱스 키 값과 실제 데이터 행의 주소(RowId=포인터)가 저장됨
- 한 테이블에 여러개 생성 가능

Index Full Scan
- 리프 블록을 처음부터 끝까지 스캔
- 부분범위처리는 인덱스 필터 조건을 만족하는 데이터가 많을수록 효과적
- 힌트 없음

Index Fast Full Scan
- 논리적인 인덱스 트리 구조 무시
- Multiblock IO방식으로 스캔
- 병렬 스캔 가능, 정렬 결과 아님
- 힌트 ; index_ffs, no_index_ffs

Index Range Scan
- 인덱스 (A, B) 일 때 A, B 둘 모두 Null 가능이면 레인지 스캔 불가 => 구성 컬럼이 모두 Null인 레코드는 인덱스에 저장하지 않기 때문
- 부정형, or 불가
- 숫자형, 문자형 자동 형 변환 주의

Index Unique Scan
- 수직적 탐색만 하는 경우

Index Skip Scan
- 가능성이 있는 리프 블록만 액세스
- 인덱스 선두 컬럼이 조건절에 없을 때 사용
- 인덱스 선두 컬럼이 조건절에 있을 때도 사용할 수 있다.
- In 조건이 인덱스 액세스 조건일 때는 사용 불가
- 힌트 ; index_ss, no_index_ss
- 선행 컬럼의 distinct value가 적고, 후행의 distinct value가 많을 때 유용

B* tree 인덱스

리버스 키 인덱스
- 인덱스 키 값을 역으로 변환해서 저장
   => 맨 우측 리프 블록의 경합 해결

비트맵 인덱스
- 읽기 위주의 대용량 DW환경에 적합
- lock에 의한 dml 부하가 큼

클러스터 인덱스

함수기반 인덱스
- 인덱스에도 함수를 적용한 상태로 값을 저장
  => 조건절에서 인덱스 컬럼에 함수를 적용해도 인덱스 스캔 가능

클러스터형 인덱스 -sql server
- 인덱스에서 테이블로의 랜덤 액세스 부하를 줄이는 용도
- 기준이 pk컬럼이 아니어도 된다
- 한 개만 생성 가능
- 클러스터형 인덱스를 생성하면 다른 비클러스터형 인덱스는 재구성됨


인덱스 Row Id
- 논리적으로 연결된 주소


인덱스 클러스터링 팩터
- 특정 컬럼을 기준으로 데이터가 테이블에 얼마나 잘 정렬되어있는지를 나타내는 지표
- 인덱스 컬럼 순으로 테이블을 재생성하면 클러스터링 팩터가 좋아짐


온라인 트랜잭션 프로그램 vs 배치 프로그램
- 온라인 : 소량 데이터를 읽고 갱신, NL조인, 부분범위 처리
- 배치 : 대량 데이터, 항상 전체범위처리, full scan, 해시조인 


인덱스 뒤쪽에 컬럼을 추가하면
- 인덱스 높이 증가
- 인덱스 사이즈 증가
- 인덱스 리프 블록이 많아지므로, 스캔 과정에 I/O발생량 증가
- 인덱스 클러스터링 팩터는 나빠짐, 좋아지지는 않음


배치 I/O 기능
- 읽는 블록마다 건건이 I/O call을 발생시키는 비효율을 줄이기 위해 고안한 기능
- 테이블 블록에 대한 디스크 I/O call을 미뤘다가 읽은 블록이 일정량 쌓이면 한번에 처리
- 부분 범위 처리 가능
- 데이터 정렬 순서가 변경됨
- 디스크 I/O가 발생하지 않으면 성능에는 차이없음


인덱스 스캔 효율
- 인덱스 컬럼을 조건절에서 모두 = 조건으로 사용할 때 가장 효율이 좋음
- 뒤쪽 컬럼이 조건절에 없거나 =이 아닌것은 비효율이 없음
- 인덱스 선행 컬럼이 조건절에 없거나, 부등호 같은 범위검색 조건이면 스캔 비효율


??
1. sql튜닝에서 '조건절 나열 순서는 sql 성능에 영향을 주지 않는다' 뜻 / 인덱스 선두 컬럼이 조건절에 포함되어있어야 하는거 아닌가?













