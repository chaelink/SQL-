### 핵심노트 Chapter 6

소트 연산 수행 과정
- PGA에 할당한 sort area에서 수행하며 pga가 부족하면 temp스페이스 사용
- 메모리 소트 : pga 내에서 소트 완료하는 경우
- 디스크 소트 : temp 테이블 스페이스까지 사용하여 소트를 완료하는 경우

SGA(System Global Area)
- 오라클 인스턴스 시작 시 할당, 모든 사용자 세션이 공유하는 메모리 영역
- db 내에 단 하나만 존재
- 주요 구성 요소 
    - Shared Pool : SQL문, 데이터 딕셔너리 정보 공유
    - Database Buffer Cache : 디스크에서 읽은 데이터 블록 저장
    - Redo Log Buffer : 변경된 데이터의 로그 정보 저장

PGA(Program Global Area)
- 개별 서버 프로세스에게 할당되는 전용 메모리 공간
- 사용자 세션마다 독립적으로 존재
- 주요 용도
    - 세션 정보 관리
    - 소트 작업
    - 조인 워크스페이스 

버퍼캐시
- 디스크에서 한 번 읽어온 데이터를 메모리에 임시로 저장하여,
- 이후 동일한 데이터 요청 시 느린 디스크 io 대신 빠른 메모리 접근을 가능하게 함

버퍼캐시 vs 일반캐시 차이
- 버퍼 캐시 : 디스크io 등 특정 입출력 효율화를 위해 데이터를 일시 보관 후 삭제
- 일반 캐시 : 자주 쓰는 데이터의 재사용을 위해 복사본을 지속적으로 저장

소트 튜닝 종류
- Sort Runs : Sort Area가 찰 때마다 Temp 영역에 저장해 둔 중간 단계의 집합
- Optimal 소트 : 정렬 대상 집합이 크지 않아 Sort Area 내에서 작업을 마무리하는 것
- Onepass 소트 : 실행계획에 나타난 하나의 소트 오퍼레이션에 대해 정렬 대상 집합을 **디스크에 한번만 기록하고 작업을 마치는 것**
- Multipass 소트 : 디스크에 여러 번 기록하는 것

<br>

소트 오퍼레이션 종류
- Sort Aggregate : sum, min, max 등 집계 계산 / Sort Area를 가장 적게 사용
- Sort Order By : 전체 데이터 정렬 / Sort Area를 가장 많이 사용
- Sort Group By : 전체 데이터를 정렬하지는 않음 / 결과집합 건수만큼의 Sort Area 사용
- Hash group By : Sort 알고리즘 대신 Hash 알고리즘을 사용한다는 점만 다름
- Sort Unique

<br>

Direct Path I/O
- (Sort Area 부족) -> Sort Area에 정렬된 데이터를 Temp 테이블스페이스에 쓰고 이를 다시 읽어 들일 때 사용
- I/o call이 완료될 때까지 대기 발생
    - direct path write temp
    - direct path read temp

<br>

커밋
- 커밋 발생 시, 네트워크를 경유한 db call 발생

<br>

배치 프로그램
= 부분범위처리 불가
- 병렬 처리 가능
- nologging 옵션은 insert 시에만 사용 가능
- Array Processing 가능

<br>

데이터베이스 Call
- 애플리케이션 커서를 캐싱하지 않는 한, 바인드 변수를 사용해도 Parse Call은 매번 일어남
- DML은 Parse call 단계를 제외하면 모든 I/O가 Execute call 단계에서 발생
- select 문은 대부분 i.o가 Fetch Call 단계에서 발생
- Parse Call 단계에서 Recursive Call 발생 가능 (하드 파싱)
- Execute Call 단계에서 Recursive Call 발생 가능
- Fetch Call 단계에서 Recursive Call 발생 가능

<br>

Array Processing
- 성능 효과의 핵심 부분 : 데이터베이스 call 감소
- java 프로그램은 네트워크를 경유하므로, PL/SQL 보다 데이터베이스 부하가 더 큼, 따라서 Array Processing 적용 후의 성능 효과도 더 큼
- Array 단위를 늘리면 성능이 좋아지지만 개선율 감소, 적정 크기로 설정해야 함
- ArraySize를 작게 설정하거나, 조건절을 충족하는 데이터가 많아서 빨리 채울수록 응답속도가 빠름

<br>

### DB 저장형 함수

DB 저장형 사용자 정의 함수(user defined function)/프로시저
- 가상연산(vm) 상에서 실행되는 Interpreting 언어
- 호출 시마다 SQL 실행엔진과 PL/SQL 가상머신 사이에 Context Switching 발생
- 함수/프로시저에 내장된 sql이 참조하는 테이블에 변경이 일어나면, 이후 최초 실행 시점에 재컴파일 발생
- 함수에 sql이 내장되어 있으면, 함수 실행 횟수만큼 Recursive call 발생
- 함수가 select list에 있다면, 결과집합 건수만큼 함수 실행
- 함수가 조건절에 있다면, 필터 처리되는 건수만큼 함수 실행
- DBMS에 직접 저장되어 SQL 문 내에서 호출할 수 있는 사용자 정의 논리 블록
- 장점 : 절차형 SQL을 활용해 계산, 문자열 조작, 비즈니스 로직을 캡슐화, 컴파일 계획 캐싱을 통해 반복 실행 시 성능 향상

DB 저장형 함수 - 성능 저하 해소 방법
- case문, 조인문으로 전환
- (아래는 효과가 큰 순으로 나열한 것)
- 스칼라 서브쿼리를 씌워서 실행, 스칼라 서브쿼리는 sql단위로 캐싱 기능이 작동함. 단, 함수에 입력하는 값 종류가 많지 않아야 한다. 왜?
- Deterministic 함수로 전환하여 캐싱 사용
- Result 캐시 기능 활용
- Native 컴파일

DB 저장형 함수의 읽기 일관성 이슈(read consistency)
- Deterministic 함수는 Fetch Call 단위로 캐싱하므로 함수 결과의 일관성 보장 X
- 함수를 스칼라 서브쿼리에 씌워서 실행도, 일관성 보장 X
- 스칼라 서브쿼리 조인은 일관성 보장 O


### 파티션
- 파티션 키 컬럼을 가공하지 않는 것이 좋다
- 가급적 실행계획에 'PARTITION RANGE ALL' 오퍼레이션이 나타나지 않도록 SQL을 작성해야 한다
- 파티션 키가 문자형 컬럼이면, LIKE 조건보다 BETWEEN 조건이 성능이 더 좋다
- 정적 Pruning 과 동적 Pruning 간 성능 차이는 거의 없다
- 


파티션 이점
- 성능 향상
- 경합 분산
- 백업 및 복구, 대량 데이터 처리가 빨라 가용성 향상
- 단점 : 저장 공간 효율성은 떨어짐



테이블 파티션 종류
1. Range 파티션
    - 파티션 기준으로 여러 컬럼 선택 가능
    - 파티션 기준 컬럼은 NUMBER, DATE형, 문자형
    - 과거 파티션에 대량 변경이나 백업 또는 복구를 진행하는 중에도 최신 파티션을 통한 조회, 변경, 삭제는 정상적으로 진행할 수 있다.
    - 입력 공간을 찾지 못해 에러가 발생하는 현상을 방지하려면, MAXVALUE 파티션을 추가해야함
2. 해시 파티션
    - DBMS가 정한 해시 알고리즘으로 데이터 분할 -> 값의 분포가 고르지 않을 때, 특정 파티션에 데이터가 몰리는 현상 발생 가능 => 이를 해결하는 옵션을 제공하지 않으므로 데이터 분포가 고른 컬럼을 파티션 키로 선정해야 함
    - DML 경합을 분산하는데 큰 도움이 된다.
    - 파티션 기준으로 여러 컬럼 선택 가능
    - 입력 공간을 찾지 못해 에러가 발생하는 현상은 발생하지 않음
3. 리스트 파티션
     - 파티션 기준으로 하나의 컬럼만 선택 가능
     - 사용자가 지정한 불연속적인 값의 목록으로 데이터를 분할하고자 할 때 사용 (? 이게 뭔말 파티션 기준으로 컬럼 하나만 사용 가능한데 어떻게 불연속적인 값의 목록이라고 말하는건지 모르겟다)
     - 하나의 파티션에서 대량 변경 백업 복구 등을 진행하는 동안 다른 파티션에서 조회, 변경, 삭제 정상 실행 가능
     - 입력 공간을 찾지 못해 에러가 발생하는 현상을 방지하려면, DEFAULT 파티션을 추가해야함

<br>

파티션 Pruning 종류
- 정적 파티션 Pruning
    - 파티션 키 컬럼을 상수 조건으로 조회하는 경우에 작동
    - 액세스할 파티션이 쿼리 최적화 시점에 미리 결정됨
    - 실행계획의 Pstart 컬럼에는 액세스할 파티션 번호가 출력됨
- 동적 파티션 Pruning
    - 파티션 키 컬럼을 바인드 변수로 조회하면 퀄 최적화 시점에는 액세스할 파티션을 미리 결정할 수 없다
    - 실행 시점이 되어서야 사용자가 입력한 값에 따라 결정됨
    - 실행계획의 Pstart와 pstop 컬럼에는 'KEY'라고 표시됨
    - NL조인을 할 때도 Inner 테이블이 조인 컬럼 기준으로 파티셔닝 되어 있다면 동적 Pruning이 작동한다 
- 고급 파티션 Pruning
    - 서브쿼리 Pruning
    - 조인 필터(블룸 필터) Pruning 


<br>

로컬 파티션 인덱스
- 테이블 파티션을 재구성할 때 Unusable 상태로 변하지 않음
    - 비파티션 인덱스, Global 파티션 인덱스는 Unusable 상태로 변함 
- 파티션도 자동으로 재구성되므로 관리의 편의성이 좋다
- 테이블 파티션별로 인덱스를 생성하므로 비파티션 인덱스보다 크기가 적다
- 루트에서 리프까지의 Depth가 낮기 때문에 인덱스를 탐색할 때 더 적은 블록을 읽는다




---
### 헷갈리는 내용
- Sort Group By, Hash group By 차이
    -  Hash Group By는 해시 함수를 사용하여 메모리(Hash Area)에서 빠르게 그룹핑하여 대용량 데이터에 유리하지만 정렬 순서를 보장하지 않음
    -  Sort Group By는 데이터를 먼저 정렬(Sort Area)한 후 그룹핑하여 정렬된 결과를 얻을 수 있으나 데이터 양이 많으면 성능 저하
- GROUP BY에서 소트 연산 생략(부분 범위 처리) 가능하게 인덱스 짜는 방법
    - group by 컬럼이 선두 컬럼인 인덱스를 사용하면 가능 
- "Top N STOPKEY 알고리즘" 작동 가능한 SQL 쿼리 작성 법
    - 인라인 뷰 안쪽에 ORDER BY 명시
    - 바로 바깥쪽에 ROWNUM <= 조건 명시
- 소트 연산 생략이 가능하도록 하는 인덱스 구성 공식
    - '=' 연산자로 사용한 조건절 컬럼 선정
    - ORDER BY 절에 기술한 컬럼 추가
    - '=' 연산자가 아닌 조건절 컬럼은 데이터 분포를 고려해 추가 여부 결정 

- 커밋, 서버 프로새스가 변경한 블록이 커밋 시점에 바로 데이터파일에 기록되지는 않는다. ?
- 친절한 sql 튜닝에서 `INSERT INTO SELECT` 내용 다시 확인하기
- 페이징 처리 기법을 사용하면 데이터베이스 Call 부하를 줄인다.
    - 왜?, 페이징 지정 값까지만 출력하고 멈추기 때문에? 
- I/O Call을 정확히 어디로 날리는 건지
- DB 저장형 사용자 정의 함수(user defined function)/프로시저의 특징
- sql 프로그램에 내장된 sql은 오라클이 자동으로 커서 캐싱, 따라서 Parse call 1회만 발생
- DB 저장형 함수에 대한 조건절이 필터 조건이면 필터링 횟수만큼 수행되고, 인덱스 액세스 조건이면 단 1회 수행됨 ?
- 파티션 인덱스, 인덱스 파티션은 같은 말?
- 파티션 기준으로 여러 컬럼을 선택할 수 있다 ?
- 각 파티션 종류 별로 파티션 pruning 조건 ?
- 파티션 키 컬럼이란, 파티션할 때 기준으로 사용하는 컬럼?
- 파티션 pruning 종류 자세히 이해하기
- 로컬 파티션 인덱스에서 "테이블의 파티션 구조와 동일하게" 라는 말의 뜻?
- 테이블 구성, sql문 보고 인덱스 고르는 법 연습 









