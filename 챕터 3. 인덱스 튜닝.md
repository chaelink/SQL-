## 챕터 3. 인덱스 튜닝

### 1절 인덱스 기본 원리

- B*Tree 인덱스 구조 설명
   - 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다
   - 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다
   - 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다
   - 리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다
   - 리프 블록의 각 로우와 테이블 로우 간은 1:1 관계다
   - 리프 블록 끼리는 양방향 연결리스트(이중연결리스트) 구조다

<br>

- 인덱스 구조 : 사용자가 지정한 컬럼(key), 해당 행의 RowId
- 인덱스 RowId 
   - 데이터베이스 테이블의 각 행이 저장된 물리적 위치를 나타내는 고유 식별자
   - 인덱스 RowId 구조 : 데이터파일 번호 + 블록 번호 + 블록 내 로우 번호

<br>

- 인덱스 힌트 작성법 정리
   - 4번 문제 이해 완
   - INDEX 힌트로 명시한 순서는 인덱스 컬럼 순서와 동일해야함 
  
<br>

- sql server 테이블 힌트 WITH
   - `FROM 테이블명 WITH (INDEX(인덱스명))` 
   - 일반적인 기술 방법
   - `FROM 고객 WITH(INDEX(고객_PK)`
   - `FROM 고객 WITH(INDEX=고객_PK)`
   - `OPTION (TABLE HINT(고객, INDEX(고객_PK))`
- 클러스터형 인덱스가 **있는** 상황
   - WITH(INDEX(0))
      - 클러스터형 인덱스를 SCAN 하면서 조건절 필터링
   - WITH(INDEX(1))
      - 클러스터형 인덱스를 검색(SEEK)
- 클러스터형 인덱스가 **없는** 상황
   - WITH(INDEX(0))
      - 테이블 풀 스캔 
   - WITH(INDEX(1))
      - 구문 오류 발생

<br>

클러스터형 인덱스
- 테이블의 실제 데이터 행 자체를 인덱스 키순서대로 정렬하여 저장
- 리프 페이지가 곧 실제 데이터 페이지
- 테이블 당 1개만 존재, 주로 pk에 설정

비 클러스터형 인덱스
- 인덱스 구조와 실제 데이터 저장 방식이 분리되어 있음
- 리프 노드에는 인덱스 키 값과 실제 데이터 행의 주소(RowId=포인터)가 저장됨
- 한 테이블에 여러개 생성 가능

<br>

인덱스 스캔 종류 5개 

1. Index Full Scan
- 리프 블록을 처음부터 끝까지 스캔
- 부분범위처리는 인덱스 필터 조건을 만족하는 데이터가 많을수록 효과적
- 인덱스 필터 조건을 만족한다 == WHERE 조건을 만족한다
- 힌트 없음(인덱스의 선두 컬럼이 조건절에 없으면 자동으로 Index Full Scan이 선택됨)

2. Index Fast Full Scan
- 논리적인 인덱스 트리 구조 무시
- Multiblock IO 방식으로 스캔
- 병렬 스캔 가능, 정렬 결과 아님
- **인덱스에 포함된 컬럼으로만 조회할 때** 사용할 수 있다
- 힌트 : index_ffs, no_index_ffs

3. Index Range Scan
- 인덱스 (A, B) 일 때 A, B 둘 모두 Null 가능이면 레인지 스캔 불가 => 구성 컬럼이 모두 Null인 레코드는 인덱스에 저장하지 않기 때문
- 부정형, or 조건은 Index Range Scan 불가
- 인덱스 컬럼을 변형하면 Index Range Scan 불가
- 숫자형, 문자형 자동 형 변환 주의
- or 조건에 대한 Index Range Scan
   - or 조건은 기본적으로는 Index Range Scan 불가
   - 다만, CONCATENATION(옵티마이저에 의한 UNION ALL 분기)로 처리했을 때 Index Range Scan 가능

4. Index Unique Scan
- 수직적 탐색만 하는 경우

5. Index Skip Scan
- **가능성**이 있는 리프 블록만 액세스
- 인덱스 선두 컬럼이 조건절에 없을 때 사용
- 인덱스 선두 컬럼이 조건절에 있을 때도 사용할 수 있다.
- In 조건이 인덱스 액세스 조건일 때는 사용 불가
- 힌트 : index_ss, no_index_ss
- 선행 컬럼의 distinct value가 적고, 후행의 distinct value가 많을 때 유용

<br>

- 인덱스 종류 정리
   - B* tree 인덱스
   - 비트맵 인덱스
      - 읽기 위주의 대용량 DW환경에 적합
      - lock에 의한 dml 부하가 큼
   - 클러스터 인덱스
   - 함수기반 인덱스
      - 인덱스에도 함수를 적용한 상태로 값을 저장하는 것 => 조건절에서 인덱스 컬럼에 함수를 적용해도 인덱스 스캔 가능
  - 리버스 키 인덱스
      - 인덱스 키 값을 역으로 변환해서 저장 => 맨 우측 리프 블록의 경합 해결
   - 클러스터형 인덱스 -sql server
      - 인덱스에서 테이블로의 랜덤 액세스 부하를 줄이는 용도
      - 기준이 pk컬럼이 아니어도 된다
         - 오라클 iot는 pk 컬럼을 기준으로 정의해야 함 
      - 한 개만 생성 가능
      - 클러스터형 인덱스를 생성하면 다른 비클러스터형 인덱스는 재구성됨

<br>

- IOT(Index Organized Table)
   -  테이블 데이터를 인덱스 구조로 저장하는 테이블
   -  SQL SERVER 클러스터형 인덱스 - IOT와 거의 동일
   -  그럼 비클러스터형 인덱스도 SQL SERVER에서만 존재? -> 아님 오라클에도 존재

| 구조          | 리프 노드 내용   | 테이블 접근 필요? |
| ----------- | ---------- | ---------- |
| 일반 인덱스      | 키 + RowID  | ⭕ 필요       |
| 클러스터형 / IOT | 키 + 전체 데이터 | ❌ 필요 없음    |

<BR>

| 구분        | 클러스터형 인덱스  | IOT       |
| --------- | ---------- | --------- |
| DBMS      | SQL Server | Oracle    |
| 리프 = 데이터  | O          | O         |
| 테이블 별도 존재 | X          | X         |
| PK 기반 정렬  | 보통 PK      | 반드시 PK    |
| 개념 차이     | 인덱스 종류     | 테이블 저장 방식 |

<BR>

- IN LIST ITERATOR
   - IN 조건을 여러개의 = 조건으로 나누어 각각 인덱스 탐색을 반복 수행하는 실행 방식 
   ```
   empno = 100
   OR empno = 200
   OR empno = 300
   ```
  - 선두 컬럼이 IN 조건에 있을 때 발생
  - 선두 컬럼이 조건에 없으면 IN LIST ITERATOR 이 발생하지 않음


### 2절 테이블 액세스 최소화


**인덱스 클러스터링 팩터**
- 특정 컬럼을 기준으로 데이터가 테이블에 얼마나 잘 정렬되어있는지를 나타내는 지표
- 인덱스 ROWID로 테이블에 액세스한 후 얻은 포인터를 저장함 (버퍼 Pinning)
   - 이후 다음 인덱스가 같은 블록을 가리키면 바로 테이블 블록 조회 가능
- 인덱스 클러스터링 팩터가 가장 좋은 상태 = 인덱스 레코드 정렬 순서와 테이블 레코드 정렬 순서가 100% 일치하는 것

- 인덱스 컬럼 순으로 테이블을 재생성하면 클러스터링 팩터가 좋아짐
- 통계 정보의 일종으로, 인덱스를 경유해 테이블 전체 로우를 액세스할 때 읽을 것으로 예상되는 논리적인 블록 갯수를 미리 구해 놓은 값

<br>

**인덱스 손익분기점**
- Index Range Scan에 의한 테이블 액세스가 Table Full Scan보다 느려지는 지점
- 보통 인덱스 손익분기점은 (5 ~ 20%) 수준
- CF에 따라 크게 달라짐(CF가 나쁘면 손익분기점도 낮고, 높으면 높음)
- 멀티블록 io 단위를 늘리면 손익분기점이 내려감

<br>

온라인 트랜잭션 프로그램 vs 배치 프로그램
- 온라인 : 소량 데이터를 읽고 갱신, NL조인, 부분범위 처리
- 배치 : 대량 데이터, 항상 전체범위처리, full scan, 해시조인 

<br>

인덱스 뒤쪽에 컬럼을 추가하면
- 인덱스 높이 증가
- 인덱스 사이즈 증가
- 인덱스 리프 블록이 많아지므로, 스캔 과정에 I/O발생량 증가
- 인덱스 클러스터링 팩터는 나빠짐, 좋아지지는 않음

<br>

**배치 I/O 기능-오라클**
- 실행계획에 'BATCHED' 키워드
- 읽는 블록마다 건건이 I/O call을 발생시키는 비효율을 줄이기 위해 고안한 기능
- 테이블 블록에 대한 디스크 I/O call을 미뤘다가 읽은 블록이 일정량 쌓이면 한번에 처리
- 부분 범위 처리 가능
- 데이터 정렬 순서가 변경됨
- 디스크 I/O가 발생하지 않으면 성능에는 차이없음

<br>

### 3절 인덱스 스캔 효율화

인덱스 스캔 효율
- 인덱스 컬럼을 조건절에서 **모두 = 조건으로 사용할 때 가장 효율이 좋음**
- 뒤쪽 컬럼이 조건절에 없거나 =이 아닌것은 비효율이 없음
- 인덱스 **선행 컬럼이 조건절에 없거나, 부등호 같은 범위검색 조건이면 스캔 비효율**

<br>







---


### 헷갈리는 내용
- 테이블 파티션이 테이블 랜덤 액세스 부담 해소에 도움이 되는 이유 ? (19번문제)
- 문제 23번 다시 이해하기, is null 일 때 인덱스 레인지 스캔 가능 여부
- 25, 26번 sql, 바인드 변수 읽는 법 알아보기
- 31번 다시 풀기
- 손익분기점이 낮다 == 인덱스 성능이 안좋다?
- 배치 프로그램에서는 해시 조인의 활용성이 높다
   - 이 선지 이해 안됨
- 36번 문제 실행결과표에서 각 단어 읽는 법
- 오라클의 배치 io 와 일반적인 배치 프로그램 은 다른 것 ?
   - 배치 io는 부분 범위 처리 가능, 모아서 한번에 디스크 io 하는 기능
   - 배치 프로그램은 사용자 개입없이 대량 데이터를 자동으로 작업하는 것, 부분범위 처리 불가능
- 40번 문제 3번 선지 이해 안됨
  3절
- 인덱스 스캔 비효율이란? 정확히 어떤 뜻인지
- 41번 문제 sql 트레이스 보는 법 알아보기, 문제 다시 풀기
- 45, 46, 47번 문제 해설 보기

 











