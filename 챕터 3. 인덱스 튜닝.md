## 챕터 3. 인덱스 튜닝

### 1절 인덱스 기본 원리

- b트리 인덱스 구조 설명
   - 브랜치 블록의 각 로우는 하위 블록에 대한 주소값을 갖는다
   - 브랜치 블록 각 로우의 키 값은 하위 블록이 갖는 값의 범위를 의미한다
   - 리프 블록의 각 로우는 테이블 로우에 대한 주소값을 갖는다
   - **리프 블록 각 로우의 키 값과 테이블 로우의 키 값은 서로 일치한다**  ? -> 알아보기
   - 리프 블록의 각 로우와 테이블 로우 간은 1:1 관계다
   - 리프 블록 끼리는 양방향 연결리스트(이중연결리스트) 구조다

<br>

- 인덱스 구조 : 사용자가 지정한 컬럼(key), 해당 행의 RowId
- 인덱스 RowId 
   - 데이터베이스 테이블의 각 행이 저장된 물리적 위치를 나타내는 고유 식별자
   - 인덱스 RowId 구조 : 데이터파일 번호 + 블록 번호 + 블록 내 로우 번호

<br>

- 인덱스 힌트 작성법 정리
   - 4번 문제 1번 선지, c 라고만 적엇는데 어떤 인덱스가 선택될 지 어떻게 아나

<br>

- sql server **WITH절**
   - 일반적인 기술 방법
   - `FROM 고객 WITH(INDEX(고객_PK)`
   - `FROM 고객 WITH(INDEX=고객_PK)`
   - `OPTION (TABLE HINT(고객, INDEX(고객_PK))`
- 클러스터형 인덱스가 **있는** 상황
   - WITH(INDEX(0))
      - 클러스터형 인덱스를 SCAN 하면서 조건절 필터링
   - WITH(INDEX(1))
      - 클러스터형 인덱스를 검색
- 클러스터형 인덱스가 **없는** 상황
   - WITH(INDEX(0))
      - 테이블 풀 스캔 
   - WITH(INDEX(1))
      - 구문 오류 발생

<br>

클러스터형 인덱스
- 테이블의 실제 데이터 행 자체를 인덱스 키순서대로 정렬하여 저장
- 리프 페이지가 곧 실제 데이터 페이지
- 테이블 당 1개만존재, 주로 pk에 설정

비 클러스터형 인덱스
- 인덱스 구조와 실제 데이터 저장 방식이 분리되어 있음
- 리프 노드에는 인덱스 키 값과 실제 데이터 행의 주소(RowId=포인터)가 저장됨
- 한 테이블에 여러개 생성 가능

<br>

인덱스 스캔 종류 5개 

1. Index Full Scan
- 리프 블록을 처음부터 끝까지 스캔
- 부분범위처리는 인덱스 필터 조건을 만족하는 데이터가 많을수록 효과적
- 인덱스 필터 조건을 만족한다 == 조건을 충족하는 행이다 ?
- 힌트 없음(인덱스의 선두 컬럼이 조건절에 없으면 자동으로 Index Full Scan이 선택됨)

2. Index Fast Full Scan
- 논리적인 인덱스 트리 구조 무시
- Multiblock IO 방식으로 스캔
- 병렬 스캔 가능, 정렬 결과 아님
- 인덱스에 포함된 컬럼으로만 조회할 때 사용할 수 있다
- 힌트 : index_ffs, no_index_ffs

3. Index Range Scan
- 인덱스 (A, B) 일 때 A, B 둘 모두 Null 가능이면 레인지 스캔 불가 => 구성 컬럼이 모두 Null인 레코드는 인덱스에 저장하지 않기 때문
- 부정형, or 불가
- 숫자형, 문자형 자동 형 변환 주의

4. Index Unique Scan
- 수직적 탐색만 하는 경우

5. Index Skip Scan
- **가능성**이 있는 리프 블록만 액세스
- 인덱스 선두 컬럼이 조건절에 없을 때 사용
- 인덱스 선두 컬럼이 조건절에 있을 때도 사용할 수 있다.
- In 조건이 인덱스 액세스 조건일 때는 사용 불가
- 힌트 : index_ss, no_index_ss
- 선행 컬럼의 distinct value가 적고, 후행의 distinct value가 많을 때 유용

<br>

- 인덱스 종류 정리
   - B* tree 인덱스

   - 리버스 키 인덱스
      - 인덱스 키 값을 역으로 변환해서 저장 => 맨 우측 리프 블록의 경합 해결

   - 비트맵 인덱스
      - 읽기 위주의 대용량 DW환경에 적합
      - lock에 의한 dml 부하가 큼

   - 클러스터 인덱스

   - 함수기반 인덱스
      - 인덱스에도 함수를 적용한 상태로 값을 저장 => 조건절에서 인덱스 컬럼에 함수를 적용해도 인덱스 스캔 가능

   - 클러스터형 인덱스 -sql server
      - 인덱스에서 테이블로의 랜덤 액세스 부하를 줄이는 용도
      - 기준이 pk컬럼이 아니어도 된다
      - 한 개만 생성 가능
      - 클러스터형 인덱스를 생성하면 다른 비클러스터형 인덱스는 재구성됨


<br>


인덱스 클러스터링 팩터
- 특정 컬럼을 기준으로 데이터가 테이블에 얼마나 잘 정렬되어있는지를 나타내는 지표
- 인덱스 컬럼 순으로 테이블을 재생성하면 클러스터링 팩터가 좋아짐


온라인 트랜잭션 프로그램 vs 배치 프로그램
- 온라인 : 소량 데이터를 읽고 갱신, NL조인, 부분범위 처리
- 배치 : 대량 데이터, 항상 전체범위처리, full scan, 해시조인 


인덱스 뒤쪽에 컬럼을 추가하면
- 인덱스 높이 증가
- 인덱스 사이즈 증가
- 인덱스 리프 블록이 많아지므로, 스캔 과정에 I/O발생량 증가
- 인덱스 클러스터링 팩터는 나빠짐, 좋아지지는 않음


배치 I/O 기능
- 읽는 블록마다 건건이 I/O call을 발생시키는 비효율을 줄이기 위해 고안한 기능
- 테이블 블록에 대한 디스크 I/O call을 미뤘다가 읽은 블록이 일정량 쌓이면 한번에 처리
- 부분 범위 처리 가능
- 데이터 정렬 순서가 변경됨
- 디스크 I/O가 발생하지 않으면 성능에는 차이없음


인덱스 스캔 효율
- 인덱스 컬럼을 조건절에서 모두 = 조건으로 사용할 때 가장 효율이 좋음
- 뒤쪽 컬럼이 조건절에 없거나 =이 아닌것은 비효율이 없음
- 인덱스 선행 컬럼이 조건절에 없거나, 부등호 같은 범위검색 조건이면 스캔 비효율


---

### 헷갈리는 내용
- WITH절 등장배경, 사용 케이스 등
- 6번 문제 2번 선지, 인덱스의 컬럼과 조건절 컬럼이 다른데 인덱스를 사용하도록 강제하고 있음, 그러면 인덱스 풀 스캔으로 진행되나?
- 인덱스 유니크 스캔 공부하기, 수직적 탐색만 하면 인덱스 리프 블록에 데이터 전체를 담고 있어야 하나?
- IN LIST ITERATOR 완벽 이해스캔 과정에 I/O발생량 증가
- 인덱스 클러스터링 팩터는 나빠짐, 좋아지지는 않음


배치 I/O 기능
- 읽는 블록마다 건건이 I/O call을 발생시키는 비효율을 줄이기 위해 고안한 기능
- 테이블 블록에 대한 디스크 I/O call을 미뤘다가 읽은 블록이 일정량 쌓이면 한번에 처리
- 부분 범위 처리 가능
- 데이터 정렬 순서가 변경됨
- 디스크 I/O가 발생하지 않으면 성능에는 차이없음


인덱스 스캔 효율
- 인덱스 컬럼을 조건절에서 모두 = 조건으로 사용할 때 가장 효율이 좋음
- 뒤쪽 컬럼이 조건절에 없거나 =이 아닌것은 비효율이 없음
- 인덱스 선행 컬럼이 조건절에 없거나, 부등호 같은 범위검색 조건이면 스캔 비효율


---

### 헷갈리는 내용
- WITH절 등장배경, 사용 케이스 등
- 6번 문제 2번 선지, 인덱스의 컬럼과 조건절 컬럼이 다른데 인덱스를 사용하도록 강제하고 있음, 그러면 인덱스 풀 스캔으로 진행되나?
- 인덱스 유니크 스캔 공부하기, 수직적 탐색만 하면 인덱스 리프 블록에 데이터 전체를 담고 있어야 하나?
- IN LIST ITERATOR 완벽 이해, 인덱스 스킵 스캔이 왜 불가능한지 이해하기











