## 챕터 5. SQL 옵티마이저

### 1절 SQL 옵티마이징 원리

- 비용기반 옵티마이저
  - 데이터 딕셔너리에 미리 수집해둔 통계정보로 각 실행 계획의 예상비용 산정
  - 통계 정보 : 데이터양, 컬럼 값의 수, 컬럼 값 분포, 인덱스 높이, 클러스터링 팩터 등
  - 내부적으로 규칙 사용
- 규칙기반 옵티마이저
  - 미리 정해놓은 우선순위 규칙에 따라 액세스 경로 평가
  - 규칙기반은 통계 정보를 전혀 사용하지 않음
  - 대량 데이터 처리에 부적합
    -  
- 스스로 학습하는 옵티마이저

<br>

- 옵티마이저가 힌트를 무시하는 경우
  - 문법적으로 맞지 않게 힌트를 기술
  - 잘못된 참조 사용
  - 논리적으로 불가능한 액세스 경로
  - 의미적으로 맞지 않게 힌트 기술
  - 옵티마이저에 의해 내부적으로 쿼리가 변환된 경우
  - 버그 

<br>

- 최적화 목표(optimizer_mode)
  - 전체 처리속도 최적화
  - 최초 응답속도 최적화 

<br>

- 선택도 : 전체 레코드 중 조건절에 의해 선택되는 레코드 **비율**
- 카디널리티 : 전체 레코드 중에서 조건절에 의해 선택되는 **레코드 개수**

<br>

- 오라클이 수집하는 컬럼 통계 항목
  - 중복을 제거한 컬럼 값의 수
  - 최소값, 최댓값
  - 밀도
  - 평균 컬럼 길이
  - NULL 값을 가진 레코드 수
 
  
### 2절 SQL 공유 및 재사용

- Soft Parsing : sql을 라이브러리 캐시에서 찾아 곧바로 실행단계로 넘어가는 것
- Hard Parsing : 라이브러리에서 sql 찾기에 실패하여, 최적화 및 로우 소스 생성 단계까지 모두 거치는 것
- Cursor caching : 

<br>

- 공유 가능한 SQL
  - 바인드 변수를 사용하는 sql도 공유 불가능?
  - 249페이지 19번 문제 다시 보기
- 바인드 변수
  - 바인드 변수를 사용하면 한 sql에 다른 값을 입력하면서 반복 재사용할 수 있다
  - 한 sql에 대한 실행계획을 여러 프로세스가 사용할 수 있다
  - 상수 값을 사용할 때 보다 쿼리 성능이 좋지 않다
  - 최적화 과정에 컬럼 히스토그램을 사용하지 못한다 


<br>

- 커서
  - 공유 커서 : 라이브러리 캐시에 공유된 Shared SQl Area
  - 세션 커서 : PGA에 할당된 Private SQL Area
  - 애플리케이션 커서 : 세션 커서를 제어하는 클라이언트 측 핸들
  - 명시적 커서 : DECLARE 문으로 SQL문을 정의하고, 커서의 open fetch close를 명시적으로 처리하는 개발 패턴
  - 묵시적 커서 : DECLARE 문을 생략하고, 커서의 open fetch close도 dbms가 자동으로 처리하는 개발 패턴
  - 참고 블로그 : https://intser.tistory.com/18?category=1301320

<br>

- CURSOR_SHARING 파라미터
  - FORCE 설정 : SQL에 사용한 상수 값을 바인드 변수로 자동 변환해줌으로써
  - EXACT 설정 : 기본 값 



### 3절 쿼리 변환





---
### 헷갈리는 내용

- 스스로 학습하는 옵티마이저 내용 정리하기
- 컬럼 히스토그램?




---

사용자 ->(sql)-> 옵티마이저 ->(실행계획)-> 프로시저

옵티마이저 최적화 단계

사용자로부터 전달받은 쿼리를 수행할 실행계획 후보군 찾기
데이터 딕셔너리에 수집해 둔 정보로 각 실행계획의 예상비용 산정
최저비용을 나타내는 실행계획 선택

1.1.4 실행계획과 비용
실행계획

SQL 실행경로 미리보기 기능
옵티마이저의 인덱스 선정 근거 : 비용

I/O 횟수 + 예상 소요시간

1.1.5 옵티마이저 힌트
힌트 사용법 : 주석에 + 붙이기
