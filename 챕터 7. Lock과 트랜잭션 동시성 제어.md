### 챕터 7. Lock과 트랜잭션 동시성 제어

### 1절 Lock

- db 모니터링 과정에 락이 나타나는 건 자연스러운 현상이다
- db 모니터링 과정에 블로킹이 자주 나타나는 건 좋지 않은 현상이다
- lock에 의해 발생하는 문제를 해결하는 가장 효과적인 방법은 sql을 튜닝해서 io를 줄이는 것이다
- 데드락이 발생하면, dbms가 둘 중 한 세션에 에러를 발생시킴으로써 교착 상태를 해소한다
- 원자성을 해치지 않는 선에서 트랜잭션은 가능한 짧게 정의하는 것이 좋다

- 논리적, db 전체, 래치보다 강력

<br>

- 배타적 Lock
  - 데이터를 변경(INSERT, UPDATE, DELETE)할 때 사용 DML
  - 해당 데이터에 대해 다른 락(S 또는 X)을 허용하지 않아 혼자서만 데이터를 변경
  - 모든 DBMS가 DML 수행 시 배타적 Lock 사용
  - 서로 다른 컬럼을 Update 하더라도 Lock 경합을 피할 수 없음
- 공유 Lock
  - 데이터를 읽을 때 사용합니다. 여러 세션이 동시에 데이터를 읽을 수 있지만, 데이터를 변경할 수는 없음
  - SQL Server는 SELECT문으로 데이터를 읽을 때 공유 Lock 사용

<br>

- **SQL SERVER**
  - 테이블에 인덱스나 제약 조건이 없으면, INSERT 끼리는 서로 블로킹하지 않음(동시 사용 가능)
  - SQL Server는 SELECT문으로 데이터를 읽을 때 공유 Lock 사용
  - 다른 트랜잭션이 조회 중인 레코드를 읽을 때는 기다리지 않아도 된다(공유 락끼리는 같이 사용 가능)
  - 변경하는 데이터가 많아지면 Lock Escalation 이 발생한다
  - 다른 트랜잭션이 조회 중인 레코드를 변경하려면, 다음 레코드로 이동할 때까지만 기다리면 된다
- **오라클**
  - MVCC 모델을 사용하는 오라클은 SELECT문 수행 시 어떤 Lock도 사용하지 않음
  - 따라서, 다른 트랜잭션이 변경 중인 레코드를 읽어야 할 때 기다리지 않고, UNDO에서 변경 이전 값을 찾아서 읽음 

<br>

- Lock Escalation : 로우 레벨 락이 페이지, 익스텐트, 테이블 레벨 락으로 점점 화장되는 것
  - 오라클은 락을 로우 자체의 속성으로 관리하므로 Lock Escalation 이 절대 발생하지 않음 
- Lock Extension
- Lock Expansion
- Lock Enforcement

<br>

- 오라클 테이블 Lock
  - 사용 이유 : 사용자가 데이터를 갱신(DML)하는 도중에 DBA가 테이블 구조를 변경(DDL)하면 안되기 때문에 

<br>

- TM lock
- TX Lock


### 2절 트랜잭션
- 트랜잭션 격리 단계
- 트랜잭션 격리 수준 별 발생 문제


### 3절 동시성 제어
- 트랜잭션 격리성 수준을 상향 조정하면, 일관성은 좋아지고 동시성은 나빠짐
- MVCC 모델을 사용하는 DBMS에서는, 격리성 수준을 상향 조정하더라도 동시성이 나빠지지 않음

<br>

- 낙관적 동시성 제어
  - 데이터를 읽는 시점부터 아예 lock을 설정
- 비관적 동시성 제어
  - 데이터를 읽는 시점에는 lock을 설정하지 않음
  - 이후에 같은 데이터를 읽거나 변경할 때는 반드시 변경 여부를 확인해야 함 

<br>

- SELECT FOR UPDATE 문
  - WAIT 옵션 : 데이터베이스에서 락(Lock)이 걸린 행을 조회할 때, 무작정 대기하지 않고 지정한 시간(초 단위) 동안만 락 해제를 기다린 후 실패 시 에러를 반환하는 옵션
  - NO WAIT 옵션 : 대상 행이 다른 트랜잭션에 의해 이미 잠금(Lock) 상태일 때, 대기(Wait)하지 않고 즉시 오류(Error)를 발생시켜 애플리케이션에 제어권을 반환

<BR>

- 동시성 향상 방법
  - 트랜잭션 격리성 수준 상향은 동시성 향상하진 않음
    


<br>

- 오라클 MVCC의 Snapshot too old(ORA-01555) 에러



---
### 헷갈리는 내용
- TM lock, TX Lock 이 무어냐...
- 각 트랜잭션 격리, 격리 수준 문제 이해하기
- 오라클 MVCC의 장단점, Snapshot too old(ORA-01555) 에러


---

# 챕터 7. Lock과 트랜잭션 동시성 제어

---

## 1절 Lock

### 1. Lock 기본 개념

- DB 모니터링 중 Lock이 나타나는 것은 정상적인 현상
- Blocking이 자주 발생하는 것은 문제 상황
- Lock 문제 해결의 핵심은 SQL 튜닝을 통해 I/O를 줄이는 것
- Deadlock 발생 시 DBMS가 한 세션에 에러를 발생시켜 교착 상태 해소
- 트랜잭션은 원자성을 해치지 않는 범위 내에서 가능한 짧게 정의

### Lock 특징

- 특정 메모리 영역에서 발생하는 작업이 아니라, 트랜잭션이 데이터를 변경할 때 발생하는 논리적 제어 장치
- 래치(Latch)보다 상위 수준의 동시성 제어 장치
- Latch → SGA 보호용 (메모리 구조 보호)
- Lock → 데이터 정합성 보호용 (트랜잭션 보호)
  - 데이터 정합성 보장 목적

---

### 2. Lock 종류

#### 배타적 Lock (Exclusive Lock, X Lock)
- INSERT, UPDATE, DELETE 수행 시 사용
- 다른 세션의 S Lock, X Lock 모두 허용하지 않음
- 같은 로우를 서로 다른 컬럼으로 UPDATE해도 Lock 경합 발생
- 모든 DBMS는 DML 수행 시 배타적 Lock 사용

#### 공유 Lock (Shared Lock, S Lock)
- SELECT 수행 시 사용 (SQL Server)
- 여러 세션이 동시에 읽기 가능
- 데이터 변경은 불가

---

### 오라클 vs SQL Server Lock 차이

#### SQL Server
- SELECT 수행 시 공유 Lock 사용
- Lock Escalation 발생 가능
  - Row → Page → Table
- 변경 데이터가 많아지면 Lock Escalation 발생

#### 오라클
- SELECT 수행 시 Lock 사용하지 않음 (MVCC)
- Undo를 이용해 과거 버전 읽음
- Lock Escalation 절대 발생하지 않음
  - Row Lock을 Row 자체에 관리

---

### 오라클 Lock 종류

#### TM Lock (Table Lock)
- 테이블 레벨 Lock
- DDL과 DML 충돌 방지 목적
- DML 수행 시 자동 획득
- 테이블 구조 보호 역할

#### TX Lock (Transaction Lock)
- 로우 단위 Lock
- DML 수행 시 발생
- 동일 로우 접근 시 Blocking 발생
- 실제 데이터 경합의 원인

<br>

- Lock Escalation : 로우 레벨 락이 많아지면서 페이지, 익스텐트, 테이블 레벨 락으로 점점 화장되는 것 
- Lock Extension : SQL Server 내부 구현 맥락에서 나오는 개념
  - 기존 Lock의 범위를 유지하면서 같은 트랜잭션 내에서 추가 Row/Page에 대해 Lock이 계속 확장되는 것
  - 단순히 lock 개수가 늘어나는 것
- Lock Expansion : 트랜잭션이 접근 범위를 넓히면서 Lock 범위가 증가하는 현상
- Lock Enforcement : DBMS가 트랜잭션 격리 수준에 따라 필요한 Lock을 강제 적용하는 것


---

## 2절 트랜잭션

### 트랜잭션 격리 수준

| 격리 수준 | Dirty Read | Non-repeatable Read | Phantom Read |
|-----------|------------|---------------------|--------------|
| Read Uncommitted | 발생 | 발생 | 발생 |
| Read Committed | 발생하지 않음 | 발생 | 발생 |
| Repeatable Read | 발생하지 않음 | 발생하지 않음 | 발생 |
| Serializable | 발생하지 않음 | 발생하지 않음 | 발생하지 않음 |

- 트랜잭션 격리에 대한 상세 내용 : https://github.com/chaelink/CS-Tech-Study/blob/main/03_DB/10%EC%A3%BC%EC%B0%A8/DB_10%EC%A3%BC%EC%B0%A8_%EA%B6%8C%EC%B1%84%EB%A6%B0.md
- Dirty Read : 다른 트랜잭션이 변경 중인 데이터를 읽었는데 그 트랜잭션이 최종적으로 롤백됨으로써 비일관성 상태에 놓이는 현상
- Non-repeatable Read : 한 트랜잭션에서 같은 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 값을 수정 또는 삭제하여 읽은 값이 서로 달라지는 현상
- Phantom Read : 한 트랜잭션 내에서 일정 범위의 데이터를 두 번 이상 읽을 때, 다른 트랜잭션이 새로운 데이터를 추가함으로 인해 첫 번째 읽을 때 없던 데이터가 나타나는 현상



### 오라클 기본 격리 수준

- 기본 격리 수준: Read Committed
- MVCC 모델 사용
- Dirty Read 절대 발생하지 않음

---

## 3절 동시성 제어

### 격리성 vs 동시성

- 격리성 수준을 높이면 일반적으로 동시성은 낮아짐
- MVCC를 사용하는 DBMS는 격리성 수준을 높여도 동시성 저하가 적음

### 낙관적 / 비관적 동시성 제어

#### 비관적 동시성 제어

- 데이터를 읽는 시점에 Lock 설정
- 충돌 가능성을 미리 차단
- SELECT FOR UPDATE 사용

#### 낙관적 동시성 제어

- 읽는 시점에는 Lock 설정하지 않음
- 변경 시점에 충돌 여부 확인

### SELECT FOR UPDATE

- 특정 로우에 TX Lock 획득
- WAIT n → n초 대기 후 에러 반환
- NOWAIT → 즉시 에러 반환
- 동시성 제어를 명시적으로 수행할 때 사용

---

## MVCC와 Snapshot too old

### MVCC 장점

- SELECT 시 Lock 사용하지 않음
- 읽기와 쓰기 충돌 최소화
- 높은 동시성 제공

### MVCC 단점

- Undo 공간 관리 부담
- 장시간 쿼리 시 Snapshot 유지 문제 발생 가능

### ORA-01555 (Snapshot too old)

- 오래 실행되는 쿼리가 필요한 Undo 정보를 찾지 못할 때 발생
- 주요 원인
  - Undo 공간 부족
  - 잦은 Commit
  - 대량 DML 작업
- 해결 방법
  - Undo 테이블스페이스 확장
  - 장시간 쿼리 튜닝
  - Commit 전략 조정












