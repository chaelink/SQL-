### 1절 NL조인
### 2절 
### 3절


- 오라클 예상 실행 계획
- SQL Server 예상 실행계획
- 오라클 Auto trace
- 오라클 sql 트레이스

오라클 AWR(Automatic Workload Repository)
- 성능 데이터를 자동으로 수집, 저장, 분석하는 내장 기능
- 주기적인 성능 스냅샷 촬영으로 병목 현상 및 원인 파악


오라클 ASH(Active Session History) 
- DB에서 현재 활성 상태인 세션들의 활동 내역을 초 단위로 샘플링하여 기록하고 분석하는 기능
- V$ACTIVE_SESSION_HISTORY 뷰와 DBA_HIST_ACTIVE_SESSION_HISTORY 뷰에 데이터 저장
- AWR과 보통 같이 사용


오라클 동적 성능 뷰 
- DB 실시간 상태 및 성능 정보를 제공하는 가상 테이블
- 명령어가 v$로 시작


Index Skip Scan이 성능을 보이는 경우
- 데이터가 충분히 많을 때?

In List 튜닝 

NVL함수
- 옵션조건에 nvl이나 decode 함수를 사용하면 union all 형태로 쿼리 변환하므로 변별력이 좋은 컬럼에 효과적이다

NDV

NL조인
- 인덱스를 사용하는 랜덤액세스 위주의 조인 방식
- 조인할 대상 레코드가 아무리 많아도, 최초 n건 빠르게 출력 가능(부분범위 처리)
- 부분범위 처리가 불가능하더라도 소량데이터 상황에서는 효과적
- 인덱스 유무 및 구성에 따라 성능이 크게 달라짐
- outer 로우 수가 많고 inner 로우 수가 적으면 조인 순서 변경 가능
- 힌트(오라클) : ordered(from 절 순서대로), use_nl, leading(여기에 원하는 순서대로 모두 기재)
- 힌트(sql server) : force order, loop join,


소트머지조인
- 각각 데이터를 소트 후 PGA에 저장, 머지(NL조인)
- 조인 조건식이 =조건이 아닌 대량 데이터 조인에 사용
- 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)에 사용

해시조인
- 조인 컬럼을 key로 하는 해시 맵을 만들어 NL조인하는 방식
- 힌트 : use_hash
- 두 테이블이 모두 대량일 경우, divide&conquer 방식 사용
- 해시 맵은 pga 영역에 할당된 hash area에 저장

서브쿼리조인

서브쿼리
- 인라인 뷰 : from 절
- 중첩 : where 절
- 스칼라 : 한 레코드 당 하나의 값을 반환하는 서브 쿼리

실행계획 읽는 법
- cr : 논리적인 블록 요청 횟수
- pr : 디스크에서 읽은 블록 수
- pw : 디스크에 쓴 블록 수

In List Iterator
- between을 in list로 바꾸어서 =을 union all 하는 형태로 전환
- 값 개수만큼 인덱스 스캔을 위한 수직적 탐색을 함
- 선택되는 레코드끼리 멀리 떨어져 있을 때 효율이 더 좋음
- 레코드가 바로 근처에 있으면 오히려 비효율
- 정렬이 깨짐?

소트 머지 조인
- 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름없다
- 인덱스 유무에 영향을 받지 않음
- 스캔 위주의 액세스 방식 사용
- 양쪽 소스 집합으로부터 조인 대상 레코드를 찾을 때 인덱스를 사용하면 랜덤 액세스 발생
- 조인 조건이 =이 아닐때, 조인조건이 아예 없을 때도 사용 가능
- 두번째 집합은 반드시 정렬해서 PGA에 저장한 후 조인해야 함
- 첫번째 집합은 조인 컬럼에 인덱스가 있으면 pga에 저장하지 않고 조인 시작 가능
- 힌트(오라클) : use_merge( )
- 힌트(sql server) : merge join
- 해시 조인보다 더 많은 메모리 사용함
- PGA : 프로세스만을 위한 독립적인 메모리 공간으로, 데이터를 읽을 때 래치 획득 과정이 없음
- NL 조인은 인덱스로 모든 블록을 건건이 조회하므로 래치 획득 및 캐시버퍼 스캔 과정을 거쳐야 함 

해시 조인
- 수행 빈도가 낮고, 쿼리 수행 시간이 오래걸리는 대량 데이터 조인에 적합
- 해시 맵을 이용하므로 조인 컬럼에 인덱스가 없어도 상관없음
- 조인 조건 중 하나 이상이 =조건일 때만 사용 가능(모든 조인 조건이 =조건이면 가장 좋음)
- 각 해시 체인에 연결된 값이 많을수록 해시 맵 탐색 효율이 나빠짐
- 해시 맵 build input은 중복 값이 거의 없는 작은 집합일 때 가장 좋다
- DW/OLAP성 쿼리, BATCH 프로그램에 주로 사용
- 힌트(오라클) : use_hash( )
- 힌트 (sql server) : hash join


build input, swap_join_inputs


### 4절 스칼라 서브 쿼리
- SELECT절, 반드시 단 하나의 값만 반환하는 서브쿼리
- 마치 일반 컬럼처럼 취급되어 메인 쿼리의 결과 집합에 각 행에 대한 단일 값을 추가
- 주로 코드명, 상품명 등 조회에 사용

- 사용 이유 : 복잡한 계산이나 특정 단일 값을 조회할 때 메인 쿼리에 통합하여 사용 가능 -> 쿼리를 간결하게 만들고 가독성 향상
- NL조인 방식으로 실행됨
- unnest 사용 가능, unnest 쿼리 변환이 작동하지 않으면 NL조인과 같은 방식으로 조인
- **캐싱 기능을 사용**하므로, 일반 조인문보다 성능이 좋음


### 5절 고급 조인 기법

- SQL 튜닝 문제
  - 46번 같은 문제 접근 방법 알아보기 


-------
### 헷갈리는 내용


- ✔️ 블록 하나에 몇개의 레코드를 담을 수 있는지?
  - 보통 8kb(8192바이트)?
- ✔️ 카디널리티가 낮다, 높다 / 선택도가 낮다, 높다 -> 어느 경우에 인덱스를 사용해야한다, 사용하면 안된다 등 정리하기
  - 선택도가 낮을수록 인덱스 사용이 유리하다. (읽는 행의 수가 적기 때문)
  - 선택도가 높으면 테이블 full scan이 유리하다.
  - 인덱스 클러스터링 팩터 등의 변수 존재 유의
  - 같은 테이블 기준, 선택도와 카디널리티는 정비례
- ✔️ 오라클 버전에 따른 실행 계획 비교?
  - 오라클 11g 버전 이상, nl조인 시에 outer 테이블이 NESTED LOOPS 위에 존재하는 실행 계획은 없다
  - INNER 테이블이 NESTED LOOPS 위에 존재하는 경우는 있음 -> 테이블 prefetch 기능을 사용할 때
- ✔️테이블 prefetch 기능이란?
  <img width="681" height="641" alt="image" src="https://github.com/user-attachments/assets/b31271a0-67f4-4bb5-acf4-782478e517c7" />

- 인덱스 액세스 조건, 필터 조건 이해하기





