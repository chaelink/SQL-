<챕터 1>
- 오라클 아키텍처
- 오라클 용어
- fast commit
- 캐시 종류, 설명
- 캐시, 버퍼, 버퍼캐시 

---
### 1절 데이터베이스 아키텍처

- 오라클
  - 데이터베이스 : 물리적인 os 파일의 집합
  - 인스턴스 : sga 공유 메모리 영역과 이를 액세스하는 프로세스 집합
 
<br>

- 백그라운드 프로세스
  - System Monitor(SMON) : 장애가 발생한 시스템을 재기동할 때 인스턴스 복구를 수행하고, 임시 세그먼트와 익스텐트를 모니터링한다
  - Process Monitor(PMON) : 이상이 생긴 프로세스가 사용하던 리소스 복구
  - Database Writers(DBWn) : 버퍼캐시에 있는 Dirty 버퍼를 데이터파일에 기록
  - Log Writer(LGWR) : 로그 버퍼 엔트리를 로그 파일로 기록
  - Archiver(ARCn) : 꽉 찬 redo 로그가 덮어 씌여지기 전 Archive 로그 디렉토리로 백업
  - Checkpoint(CKPT) : Checkpoint 발생 시 데이터파일과 컨트롤파일의 헤더에 체크포인트 정보를 기록하고, DBWn에게 Dirty Buffer 기록을 요청하는 프로세스
  - Recoverer(RECO): 분산 트랜잭션 과정에 발생한 문제 해결

<br>

- 세그먼트 : 저장 공간을 필요로 하는 오브젝트
  - 테이블, 인덱스, 파티션, 클러스터, LOB, ROLLBACK
  - ! 뷰는 쿼리 문장을 담고 있는 가상의 테이블이므로 물리적인 저장 공간을 갖지 않음
 
<br>

- Undo 사용 목적
  - Transaction Rollback : 트랜잭션이 ROLLBACK 될 때 변경 이전 데이터로 되돌리기 위해 사용
  - Transaction Recovery : 장애 발생 시 커밋되지 않은 트랜잭션 취소에 사용
  - Read Consistency : 다른 세션이 변경 중인 데이터를 조회할 때 변경 이전의 일관된 데이터를 제공하기 위해 사용
- Undo 관련 메커니즘
  - Snapshot too old
    - 필요한 Undo 정보가 이미 덮어써져 과거 시점의 데이터를 복원할 수 없는 오류 (ORA-01555)

 <br>
 
- Redo 사용 목적
  - database Recovery : 장애 발생 시 커밋된 트랜잭션을 재적용하여 데이터파일을 복구하기 위해 사용
  - Cache Recovery : 버퍼 캐시에만 존재하던 변경 내용을 Redo를 이용해 재반영하기 위해 사용
  - Fast Commit : 데이터파일 기록을 기다리지 않고 Redo 로그만 기록하고 커밋을 완료하기 위해 사용
- Redo 관련 메커니즘
  - Log Force at Commit
  - Fast Commit
  - Write Ahead Logging 
- Redo 로그 종류
  - Online Redo 로그
    - 인스턴스가 현재 사용 중인 redo 로그 파일 
    - 최소 두 개 이상의 파일로 구성해야 함
    - LGWR이 직접 기록
    - 인스턴스가 비정상적으로 종료되었을 때 캐시를 복구하기 위해 사용 
  - Archived(Offline) Redo 로그
    - 사용이 끝난 Online redo 로그를 보관한 파일
    - 물리적인 저장 매체에 문제가 생겼을 때 데이터베이스 복구를 위해 사용(미디어 복구)

<br>

- 오라클 SGA 구성요소
  - 버퍼 캐시
  - 딕셔너리 캐시
  - 로그 버퍼

- 오라클 메모리 캐시
  - DB 버퍼 캐시 : 테이블 블록, 인덱스 블록, Undo 블록을 캐싱(데이터 블록)
  - 라이브러리 캐시 : SQL, 실행계획, DB 저장형 함수/프로시저, 트리거를 캐싱(sql 재사용, 재파싱 방지)
  - 딕셔너리 캐시(로우 캐시) : 테이블 정보, 인덱스 정보, 데이터파일 정보, 시퀀스 등을 캐싱(데이터 딕셔너리 정보)
  - Result 캐시 : SQL 결과집합을 캐싱, 동일 sql 실행 시 결과값을 재사용하기 위해(주의, sql 재사용이 아닌 결과값 재사용)


### 2절 SQL 처리 과정
- SQL 처리 과정
  - SQL 파싱 : 문법적 오류 또는 의미상 오류가 없는 지 확인하는 단계
  - SQL 최적화 : 데이터 딕셔너리에 미리 수집해 둔 오브젝트 통계 및 시스템 통계 정보 활용 (옵티마이저)
  - 로우 소스 생성 : SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅 (로우 소스 생성기)
  - SQL 실행 

<br>

- 옵티마이저 힌트는 명령어이므로, 특별한 이유가 없는 한 그대로 실행된다
- 힌트에 문법적 오류가 있어도 컴파일 에러 발생하지 않는다.(SQL SERVER는 컴파일 에러 발생)
- 옵티마이저 힌트를 사용하면 SQL 최적화 소요 시간은 감소한다
- 힌트를 느슨하게 작성하면, 옵티마이저가 결정

<br>

- 옵티마이저 힌트 작성 방법
  - 힌트 안에 인자를 나열할 땐 콤마를 사용할 수 있지만, 힌트와 힌트 사이에는 콤마를 사용하면 안됨
  - 테이블을 지정할 때 스키마 명은 명시하면 안됨
  - 테이블명 별칭을 사용했다면, 힌트에도 별칭으로 사용해야 함

### 3절 데이터베이스 I/O 메커니즘


- 블록 단위 I/O
  - 오라클을 포함한 모든 DBMS에서 블록 단위 I/O 진행
  - 딕셔너리 캐시만 예외, 데이터 딕셔너리에 저장된 테이블을 딕셔너리 캐시에 적재할 때는 로우 단위로

 <br>

- 메모리 버퍼캐시 탐색 메커니즘
  - Direct Path I/O 를 제외한 모든 블록 i/o는 메모리 버퍼캐시를 경유한다
  - 병렬 프로세스로 테이블을 full scan 할 때는 Direct path I/O 가 작동하므로 메모리 버퍼 캐시를 경유하지 않음

<br>

- 버퍼캐시 히트율 공식
  - (1 - (물리적io / 논리적 io)) * 100
  - 논리적io : sql 수행 과정에서 읽은 총 블록수
    - query 항목 + current 항목  

<br>

- 21쪽 24번 별표

<br>

- Single Block I/O
  - 인덱스를 사용하면 기본적으로 Single Block I/O 방식 사용
  - 인덱스 full scan 도 싱글 방식? -> 맞음
- Multiblock I/O
  - 테이블 Full scan
  - 인덱스 fast full scan 

 ---

 ### 헷갈리는 내용 정리 완료
 - 드라이빙 테이블 : 조인 시 가장 먼저 읽히는 테이블




